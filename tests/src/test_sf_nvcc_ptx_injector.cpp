/**
* @file test_sf_nvcc_ptx_injector.cpp
 * @brief Test sf-nvcc ptx injection
 *
 * Implements unit tests for PTX modification engine, verifying correct
 * insertion of bounds checking calls before global memory instructions
 * and proper handling of various configuration options.
 *
 * @author Kiran <kiran.pdas2022@vitstudent.ac.in>
 * @date 2025-09-22
 * @version 0.0.1
 * @copyright Copyright (c) 2025 SafeCUDA Project. Licensed under GPL v3.
 *
 * Change Log:
 * - 2025-09-22: Initial implementation with Google Test
 */

#include "test_sf_nvcc_ptx_injector.h"
#include "ptx_modifier.h"

#include <fstream>
#include <filesystem>
#include <sstream>

using namespace sf_nvcc_ptx_injection_tests;
namespace fs = std::filesystem;
namespace sf_nvcc = safecuda::tools::sf_nvcc;

static const std::string SCALE_ARRAY_PTX = R"(//
// Generated by NVIDIA NVVM Compiler
//
// Compiler Build ID: CL-36037853
// Cuda compilation tools, release 12.9, V12.9.86
// Based on NVVM 7.0.1
//

.version 8.8
.target sm_52
.address_size 64

    // .globl  _Z10scaleArrayPfi

.visible .entry _Z10scaleArrayPfi(
    .param .u64 _Z10scaleArrayPfi_param_0,
    .param .u32 _Z10scaleArrayPfi_param_1
)
{
    .reg .pred     %p<2>;
    .reg .f32  %f<3>;
    .reg .b32  %r<6>;
    .reg .b64  %rd<5>;


    ld.param.u64   %rd1, [_Z10scaleArrayPfi_param_0];
    ld.param.u32   %r2, [_Z10scaleArrayPfi_param_1];
    mov.u32    %r3, %ctaid.x;
    mov.u32    %r4, %ntid.x;
    mov.u32    %r5, %tid.x;
    mad.lo.s32     %r1, %r3, %r4, %r5;
    setp.ge.s32    %p1, %r1, %r2;
    @%p1 bra   $L__BB0_2;

    cvta.to.global.u64     %rd2, %rd1;
    mul.wide.s32   %rd3, %r1, 4;
    add.s64    %rd4, %rd2, %rd3;
    ld.global.f32  %f1, [%rd4];
    add.f32    %f2, %f1, %f1;
    st.global.f32  [%rd4], %f2;

$L__BB0_2:
    ret;

}
)";

static const std::string ADD_ONE_PTX = R"(//
// Generated by NVIDIA NVVM Compiler
//
// Compiler Build ID: CL-36037853
// Cuda compilation tools, release 12.9, V12.9.86
// Based on NVVM 7.0.1
//

.version 8.8
.target sm_86
.address_size 64

    // .globl  _Z6addOnePfi

.visible .entry _Z6addOnePfi(
    .param .u64 _Z6addOnePfi_param_0,
    .param .u32 _Z6addOnePfi_param_1
)
{
    .reg .pred     %p<2>;
    .reg .f32  %f<3>;
    .reg .b32  %r<6>;
    .reg .b64  %rd<5>;


    ld.param.u64   %rd1, [_Z6addOnePfi_param_0];
    ld.param.u32   %r2, [_Z6addOnePfi_param_1];
    mov.u32    %r3, %ctaid.x;
    mov.u32    %r4, %ntid.x;
    mov.u32    %r5, %tid.x;
    mad.lo.s32     %r1, %r3, %r4, %r5;
    setp.ge.s32    %p1, %r1, %r2;
    @%p1 bra   $L__BB0_2;

    cvta.to.global.u64     %rd2, %rd1;
    mul.wide.s32   %rd3, %r1, 4;
    add.s64    %rd4, %rd2, %rd3;
    ld.global.f32  %f1, [%rd4];
    add.f32    %f2, %f1, 0f3F800000;
    st.global.f32  [%rd4], %f2;

$L__BB0_2:
    ret;

}
)";

static const std::string COMPLEX_GLOBAL_PTX = R"(.version 8.8
.target sm_75
.address_size 64

.visible .entry complexKernel(
    .param .u64 input_ptr,
    .param .u64 output_ptr,
    .param .u32 size
)
{
    .reg .pred     %p<3>;
    .reg .f32      %f<5>;
    .reg .b32      %r<8>;
    .reg .b64      %rd<10>;

    ld.param.u64   %rd1, [input_ptr];
    ld.param.u64   %rd2, [output_ptr];
    ld.param.u32   %r1, [size];

    cvta.to.global.u64     %rd3, %rd1;
    cvta.to.global.u64     %rd4, %rd2;

    mov.u32    %r2, %tid.x;
    setp.ge.s32    %p1, %r2, %r1;
    @%p1 bra   Exit;

    mul.wide.s32   %rd5, %r2, 4;
    add.s64    %rd6, %rd3, %rd5;
    add.s64    %rd7, %rd4, %rd5;

    ld.global.f32  %f1, [%rd6];
    ld.global.f32  %f2, [%rd6 + 4];
    atom.global.add.f32 %f3, [%rd7], %f1;
    red.global.add.f32 [%rd7 + 8], %f2;
    st.global.f32  [%rd7], %f3;

Exit:
    ret;
}
)";

static const std::string EMPTY_PTX = R"(.version 8.8
.target sm_60
.address_size 64

.visible .entry emptyKernel()
{
    ret;
}
)";

static const std::string NO_GLOBAL_ACCESS_PTX = R"(.version 8.8
.target sm_60
.address_size 64

.visible .entry localOnlyKernel(
    .param .u32 value
)
{
    .reg .b32  %r<5>;
    .reg .f32  %f<3>;

    ld.param.u32   %r1, [value];
    mov.u32    %r2, %tid.x;
    add.u32    %r3, %r1, %r2;
    cvt.rn.f32.u32 %f1, %r3;
    mul.f32    %f2, %f1, 0f40000000;

    ret;
}
)";

static const std::string INPUT_PTX = R"(//
// Generated by NVIDIA NVVM Compiler
//
// Compiler Build ID: CL-36037853
// Cuda compilation tools, release 12.9, V12.9.86
// Based on NVVM 7.0.1
//

.version 8.8
.target sm_75
.address_size 64

    // .globl  _Z11vectorAddPfiS_S_i

.visible .entry _Z11vectorAddPfiS_S_i(
    .param .u64 _Z11vectorAddPfiS_S_i_param_0,
    .param .u64 _Z11vectorAddPfiS_S_i_param_1,
    .param .u64 _Z11vectorAddPfiS_S_i_param_2,
    .param .u32 _Z11vectorAddPfiS_S_i_param_3
)
{
    .reg .pred     %p<2>;
    .reg .f32      %f<4>;
    .reg .b32      %r<7>;
    .reg .b64      %rd<10>;


    ld.param.u64   %rd1, [_Z11vectorAddPfiS_S_i_param_0];
    ld.param.u64   %rd2, [_Z11vectorAddPfiS_S_i_param_1];
    ld.param.u64   %rd3, [_Z11vectorAddPfiS_S_i_param_2];
    ld.param.u32   %r2, [_Z11vectorAddPfiS_S_i_param_3];
    mov.u32    %r3, %ctaid.x;
    mov.u32    %r4, %ntid.x;
    mov.u32    %r5, %tid.x;
    mad.lo.s32     %r1, %r3, %r4, %r5;
    setp.ge.s32    %p1, %r1, %r2;
    @%p1 bra   $L__BB0_2;

    cvta.to.global.u64     %rd4, %rd1;
    cvta.to.global.u64     %rd5, %rd2;
    cvta.to.global.u64     %rd6, %rd3;
    mul.wide.s32   %rd7, %r1, 4;
    add.s64    %rd8, %rd4, %rd7;
    add.s64    %rd9, %rd5, %rd7;
    ld.global.f32  %f1, [%rd8];
    ld.global.f32  %f2, [%rd9];
    add.f32    %f3, %f1, %f2;
    add.s64    %rd10, %rd6, %rd7;
    st.global.f32  [%rd10], %f3;

$L__BB0_2:
    ret;

}
)";

static const std::string EXPECTED_OUTPUT = R"(//
// Generated by NVIDIA NVVM Compiler
//
// Compiler Build ID: CL-36037853
// Cuda compilation tools, release 12.9, V12.9.86
// Based on NVVM 7.0.1
//

.version 8.8
.target sm_75
.address_size 64

    // .globl  _Z11vectorAddPfiS_S_i

.visible .entry _Z11vectorAddPfiS_S_i(
    .param .u64 _Z11vectorAddPfiS_S_i_param_0,
    .param .u64 _Z11vectorAddPfiS_S_i_param_1,
    .param .u64 _Z11vectorAddPfiS_S_i_param_2,
    .param .u32 _Z11vectorAddPfiS_S_i_param_3
)
{
    .reg .pred     %p<2>;
    .reg .f32      %f<4>;
    .reg .b32      %r<7>;
    .reg .b64      %rd<10>;


    ld.param.u64   %rd1, [_Z11vectorAddPfiS_S_i_param_0];
    ld.param.u64   %rd2, [_Z11vectorAddPfiS_S_i_param_1];
    ld.param.u64   %rd3, [_Z11vectorAddPfiS_S_i_param_2];
    ld.param.u32   %r2, [_Z11vectorAddPfiS_S_i_param_3];
    mov.u32    %r3, %ctaid.x;
    mov.u32    %r4, %ntid.x;
    mov.u32    %r5, %tid.x;
    mad.lo.s32     %r1, %r3, %r4, %r5;
    setp.ge.s32    %p1, %r1, %r2;
    @%p1 bra   $L__BB0_2;

    cvta.to.global.u64     %rd4, %rd1;
    cvta.to.global.u64     %rd5, %rd2;
    cvta.to.global.u64     %rd6, %rd3;
    mul.wide.s32   %rd7, %r1, 4;
    add.s64    %rd8, %rd4, %rd7;
    add.s64    %rd9, %rd5, %rd7;
    call bounds_check, (%rd8);
    ld.global.f32  %f1, [%rd8];
    call bounds_check, (%rd9);
    ld.global.f32  %f2, [%rd9];
    add.f32    %f3, %f1, %f2;
    add.s64    %rd10, %rd6, %rd7;
    call bounds_check, (%rd10);
    st.global.f32  [%rd10], %f3;

$L__BB0_2:
    ret;

}
)";

void SfNvccPtxInjectionTest::SetUp()
{
	temp_file = fs::temp_directory_path() / "temp_test.ptx";
}

void SfNvccPtxInjectionTest::TearDown()
{
	if (fs::exists(temp_file)) {
		fs::remove(temp_file);
	}
}

void SfNvccPtxInjectionTest::write_ptx(const std::string_view content) const
{
	std::ofstream ofs(temp_file);
	ofs << content;
	ofs.close();
}

/**
 * @brief Tests basic bounds check insertion for simple PTX file
 *
 * Verifies that global memory instructions are properly instrumented
 * with bounds check calls while preserving original functionality.
 */
TEST_F(SfNvccPtxInjectionTest, BasicBoundsCheckInsertion)
{
	write_ptx(SCALE_ARRAY_PTX);

	sf_nvcc::SafeCudaOptions opts;
	opts.enable_verbose = false;
	opts.enable_debug = false;

	bool result = sf_nvcc::insert_bounds_check(temp_file, opts);
	EXPECT_TRUE(result);

	std::ifstream file(temp_file);
	std::string instrumented_content((std::istreambuf_iterator<char>(file)),
					 std::istreambuf_iterator<char>());

	EXPECT_NE(instrumented_content.find("call bounds_check, (%rd4);"),
		  std::string::npos);

	size_t first_bounds_check =
		instrumented_content.find("call bounds_check, (%rd4);");
	size_t second_bounds_check = instrumented_content.find(
		"call bounds_check, (%rd4);", first_bounds_check + 1);

	EXPECT_NE(first_bounds_check, std::string::npos);
	EXPECT_NE(second_bounds_check, std::string::npos);
}

/**
 * @brief Tests instrumentation of complex PTX with multiple instruction types
 *
 * Validates proper handling of load, store, atomic, and reduction operations
 * with different address register patterns.
 */
TEST_F(SfNvccPtxInjectionTest, ComplexInstructionTypeHandling)
{
	write_ptx(COMPLEX_GLOBAL_PTX);

	sf_nvcc::SafeCudaOptions opts;
	opts.enable_verbose = false;
	opts.enable_debug = false;

	bool result = sf_nvcc::insert_bounds_check(temp_file, opts);
	EXPECT_TRUE(result);

	std::ifstream file(temp_file);
	std::string content((std::istreambuf_iterator<char>(file)),
			    std::istreambuf_iterator<char>());

	EXPECT_NE(content.find("call bounds_check, (%rd6);"),
		  std::string::npos);
	EXPECT_NE(content.find("call bounds_check, (%rd7);"),
		  std::string::npos);

	std::istringstream iss(content);
	std::string line;
	int bounds_check_count = 0;
	while (std::getline(iss, line)) {
		if (line.find("call bounds_check,") != std::string::npos) {
			bounds_check_count++;
		}
	}

	EXPECT_EQ(bounds_check_count, 5);
}

/**
 * @brief Tests backup file creation when debug mode is enabled
 *
 * Verifies that original PTX files are preserved with .bak extension
 * when enable_debug is true.
 */
TEST_F(SfNvccPtxInjectionTest, DebugModeBackupCreation)
{
	write_ptx(ADD_ONE_PTX);

	sf_nvcc::SafeCudaOptions opts;
	opts.enable_debug = true;
	opts.enable_verbose = false;

	fs::path backup_file = temp_file;
	backup_file += ".bak";

	if (fs::exists(backup_file))
		fs::remove(backup_file);

	bool result = sf_nvcc::insert_bounds_check(temp_file, opts);
	EXPECT_TRUE(result);
	EXPECT_TRUE(fs::exists(backup_file));

	std::ifstream backup(backup_file);
	std::string backup_content((std::istreambuf_iterator<char>(backup)),
				   std::istreambuf_iterator<char>());

	EXPECT_EQ(backup_content, ADD_ONE_PTX);
}

/**
 * @brief Tests handling of PTX files without global memory instructions
 *
 * Validates that files with no global memory access complete successfully
 * without modification.
 */
TEST_F(SfNvccPtxInjectionTest, NoGlobalInstructionsHandling)
{
	write_ptx(NO_GLOBAL_ACCESS_PTX);

	sf_nvcc::SafeCudaOptions opts;
	opts.enable_verbose = false;
	opts.enable_debug = false;

	bool result = sf_nvcc::insert_bounds_check(temp_file, opts);
	EXPECT_TRUE(result);

	std::ifstream file(temp_file);
	std::string content((std::istreambuf_iterator<char>(file)),
			    std::istreambuf_iterator<char>());

	EXPECT_EQ(content.find("call bounds_check"), std::string::npos);
}

/**
 * @brief Tests handling of empty PTX files
 *
 * Verifies that minimal PTX files are processed without errors
 * and return successful completion status.
 */
TEST_F(SfNvccPtxInjectionTest, EmptyPtxFileHandling)
{
	write_ptx(EMPTY_PTX);

	sf_nvcc::SafeCudaOptions opts;
	opts.enable_verbose = false;
	opts.enable_debug = false;

	bool result = sf_nvcc::insert_bounds_check(temp_file, opts);
	EXPECT_TRUE(result);

	std::ifstream file(temp_file);
	std::string content((std::istreambuf_iterator<char>(file)),
			    std::istreambuf_iterator<char>());

	EXPECT_EQ(content.find("call bounds_check"), std::string::npos);
}

/**
 * @brief Tests error handling for non-existent files
 *
 * Validates that attempting to process non-existent PTX files
 * returns false and handles errors gracefully.
 */
TEST_F(SfNvccPtxInjectionTest, NonExistentFileHandling)
{
	fs::path non_existent = temp_file.parent_path() / "does_not_exist.ptx";

	sf_nvcc::SafeCudaOptions opts;
	opts.enable_verbose = false;
	opts.enable_debug = false;

	bool result = sf_nvcc::insert_bounds_check(non_existent, opts);
	EXPECT_FALSE(result);
}

/**
 * @brief Tests preservation of original formatting and indentation
 *
 * Verifies that bounds check calls match the indentation level
 * of the original global memory instructions.
 */
TEST_F(SfNvccPtxInjectionTest, IndentationPreservation)
{
	write_ptx(SCALE_ARRAY_PTX);

	sf_nvcc::SafeCudaOptions opts;
	opts.enable_verbose = false;
	opts.enable_debug = false;

	bool result = sf_nvcc::insert_bounds_check(temp_file, opts);
	EXPECT_TRUE(result);

	std::ifstream file(temp_file);
	std::string line;
	bool found_indented_bounds_check = false;

	while (std::getline(file, line)) {
		if (line.find("call bounds_check, (%rd4);") !=
		    std::string::npos) {
			EXPECT_EQ(line.find_first_not_of(" \t"), 4);
			found_indented_bounds_check = true;
			break;
		}
	}

	EXPECT_TRUE(found_indented_bounds_check);
}

/**
 * @brief Tests verbose mode output behavior
 *
 * Validates that verbose mode enables additional logging without
 * affecting the core instrumentation functionality.
 */
TEST_F(SfNvccPtxInjectionTest, VerboseModeOperation)
{
	write_ptx(ADD_ONE_PTX);

	sf_nvcc::SafeCudaOptions opts;
	opts.enable_verbose = true;
	opts.enable_debug = false;

	bool result = sf_nvcc::insert_bounds_check(temp_file, opts);
	EXPECT_TRUE(result);

	std::ifstream file(temp_file);
	std::string content((std::istreambuf_iterator<char>(file)),
			    std::istreambuf_iterator<char>());

	EXPECT_NE(content.find("call bounds_check, (%rd4);"),
		  std::string::npos);
}

/**
 * @brief Tests debug mode comprehensive functionality
 *
 * Verifies that debug mode creates backups, enables verbose logging,
 * and performs instrumentation correctly.
 */
TEST_F(SfNvccPtxInjectionTest, DebugModeComprehensive)
{
	write_ptx(COMPLEX_GLOBAL_PTX);

	sf_nvcc::SafeCudaOptions opts;
	opts.enable_debug = true;
	opts.enable_verbose = false;

	fs::path backup_file = temp_file;
	backup_file += ".bak";

	bool result = sf_nvcc::insert_bounds_check(temp_file, opts);
	EXPECT_TRUE(result);
	EXPECT_TRUE(fs::exists(backup_file));

	std::ifstream file(temp_file);
	std::string content((std::istreambuf_iterator<char>(file)),
			    std::istreambuf_iterator<char>());

	std::istringstream iss(content);
	std::string line;
	int bounds_check_count = 0;
	while (std::getline(iss, line)) {
		if (line.find("call bounds_check,") != std::string::npos) {
			bounds_check_count++;
		}
	}

	EXPECT_EQ(bounds_check_count, 5);
}

/**
 * @brief Tests mixed debug and verbose mode operation
 *
 * Validates that enabling both debug and verbose modes works correctly
 * and produces expected results with backup creation.
 */
TEST_F(SfNvccPtxInjectionTest, MixedDebugVerboseMode)
{
	write_ptx(SCALE_ARRAY_PTX);

	sf_nvcc::SafeCudaOptions opts;
	opts.enable_debug = true;
	opts.enable_verbose = true;

	fs::path backup_file = temp_file;
	backup_file += ".bak";

	bool result = sf_nvcc::insert_bounds_check(temp_file, opts);
	EXPECT_TRUE(result);
	EXPECT_TRUE(fs::exists(backup_file));

	std::ifstream file(temp_file);
	std::string content((std::istreambuf_iterator<char>(file)),
			    std::istreambuf_iterator<char>());

	size_t bounds_check_count = 0;
	size_t pos = 0;
	while ((pos = content.find("call bounds_check,", pos)) !=
	       std::string::npos) {
		bounds_check_count++;
		pos++;
	}

	EXPECT_EQ(bounds_check_count, 2);
}

/**
 * @brief Tests complete end-to-end PTX instrumentation with expected output
 *
 * Validates the entire transformation process by comparing actual output
 * against pre-configured expected instrumented PTX code for exact verification.
 */
TEST_F(SfNvccPtxInjectionTest, CompleteEndToEndTransformation)
{
	write_ptx(INPUT_PTX);

	sf_nvcc::SafeCudaOptions opts;
	opts.enable_verbose = false;
	opts.enable_debug = false;

	bool result = sf_nvcc::insert_bounds_check(temp_file, opts);
	EXPECT_TRUE(result);

	std::ifstream file(temp_file);
	std::string actual_output((std::istreambuf_iterator<char>(file)),
				  std::istreambuf_iterator<char>());

	EXPECT_EQ(actual_output, EXPECTED_OUTPUT);

	std::istringstream actual_stream(actual_output);
	std::istringstream expected_stream(EXPECTED_OUTPUT);
	std::string actual_line, expected_line;
	int line_number = 1;

	while (std::getline(actual_stream, actual_line) &&
	       std::getline(expected_stream, expected_line)) {
		EXPECT_EQ(actual_line, expected_line)
			<< "Line " << line_number << " differs\n"
			<< "Expected: '" << expected_line << "'\n"
			<< "Actual:   '" << actual_line << "'";
		line_number++;
	}
	EXPECT_EQ(std::getline(actual_stream, actual_line).eof(),
		  std::getline(expected_stream, expected_line).eof())
		<< "Files have different number of lines";

	size_t bounds_check_count = 0;
	size_t pos = 0;
	while ((pos = actual_output.find("call bounds_check,", pos)) !=
	       std::string::npos) {
		bounds_check_count++;
		pos++;
	}

	EXPECT_EQ(bounds_check_count, 3)
		<< "Expected exactly 3 bounds check calls";
}
