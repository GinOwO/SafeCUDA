/**
 * @file test_sf_nvcc_pattern_matching.cpp
 * @brief Test sf-nvcc pattern matching
 *
 * Implements unit tests for pattern_matcher, verifying correct
 * detection of global memory registers and memory instructions
 * in PTX files.
 *
 * @author Kiran <kiran.pdas2022@vitstudent.ac.in>
 * @date 2025-09-22
 * @version 1.0.0
 * @copyright Copyright (c) 2025 SafeCUDA Project. Licensed under GPL v3.
 *
 * Change Log:
 * - 2025-09-22: Initial implementation with Google Test
 */

#include "test_sf_nvcc_pattern_matcher.h"
#include "pattern_matcher.h"

#include <fstream>
#include <filesystem>

using namespace sf_nvcc_pattern_matching_tests;
namespace fs = std::filesystem;
namespace sf_nvcc = safecuda::tools::sf_nvcc;

static const std::string SCALE_ARRAY_PTX = R"(//
// Generated by NVIDIA NVVM Compiler
//
// Compiler Build ID: CL-36037853
// Cuda compilation tools, release 12.9, V12.9.86
// Based on NVVM 7.0.1
//

.version 8.8
.target sm_52
.address_size 64

    // .globl  _Z10scaleArrayPfi

.visible .entry _Z10scaleArrayPfi(
    .param .u64 _Z10scaleArrayPfi_param_0,
    .param .u32 _Z10scaleArrayPfi_param_1
)
{
    .reg .pred     %p<2>;
    .reg .f32  %f<3>;
    .reg .b32  %r<6>;
    .reg .b64  %rd<5>;


    ld.param.u64   %rd1, [_Z10scaleArrayPfi_param_0];
    ld.param.u32   %r2, [_Z10scaleArrayPfi_param_1];
    mov.u32    %r3, %ctaid.x;
    mov.u32    %r4, %ntid.x;
    mov.u32    %r5, %tid.x;
    mad.lo.s32     %r1, %r3, %r4, %r5;
    setp.ge.s32    %p1, %r1, %r2;
    @%p1 bra   $L__BB0_2;

    cvta.to.global.u64     %rd2, %rd1;
    mul.wide.s32   %rd3, %r1, 4;
    add.s64    %rd4, %rd2, %rd3;
    ld.global.f32  %f1, [%rd4];
    add.f32    %f2, %f1, %f1;
    st.global.f32  [%rd4], %f2;

$L__BB0_2:
    ret;

}
)";

static const std::string ADD_ONE_PTX = R"(//
// Generated by NVIDIA NVVM Compiler
//
// Compiler Build ID: CL-36037853
// Cuda compilation tools, release 12.9, V12.9.86
// Based on NVVM 7.0.1
//

.version 8.8
.target sm_86
.address_size 64

    // .globl  _Z6addOnePfi

.visible .entry _Z6addOnePfi(
    .param .u64 _Z6addOnePfi_param_0,
    .param .u32 _Z6addOnePfi_param_1
)
{
    .reg .pred     %p<2>;
    .reg .f32  %f<3>;
    .reg .b32  %r<6>;
    .reg .b64  %rd<5>;


    ld.param.u64   %rd1, [_Z6addOnePfi_param_0];
    ld.param.u32   %r2, [_Z6addOnePfi_param_1];
    mov.u32    %r3, %ctaid.x;
    mov.u32    %r4, %ntid.x;
    mov.u32    %r5, %tid.x;
    mad.lo.s32     %r1, %r3, %r4, %r5;
    setp.ge.s32    %p1, %r1, %r2;
    @%p1 bra   $L__BB0_2;

    cvta.to.global.u64     %rd2, %rd1;
    mul.wide.s32   %rd3, %r1, 4;
    add.s64    %rd4, %rd2, %rd3;
    ld.global.f32  %f1, [%rd4];
    add.f32    %f2, %f1, 0f3F800000;
    st.global.f32  [%rd4], %f2;

$L__BB0_2:
    ret;

}
)";

static const std::string COMPLEX_GLOBAL_PTX = R"(.version 8.8
.target sm_75
.address_size 64

.visible .entry complexKernel(
    .param .u64 input_ptr,
    .param .u64 output_ptr,
    .param .u32 size
)
{
    .reg .pred     %p<3>;
    .reg .f32      %f<5>;
    .reg .b32      %r<8>;
    .reg .b64      %rd<10>;

    ld.param.u64   %rd1, [input_ptr];
    ld.param.u64   %rd2, [output_ptr];
    ld.param.u32   %r1, [size];

    cvta.to.global.u64     %rd3, %rd1;
    cvta.to.global.u64     %rd4, %rd2;

    mov.u32    %r2, %tid.x;
    setp.ge.s32    %p1, %r2, %r1;
    @%p1 bra   Exit;

    mul.wide.s32   %rd5, %r2, 4;
    add.s64    %rd6, %rd3, %rd5;
    add.s64    %rd7, %rd4, %rd5;

    ld.global.f32  %f1, [%rd6];
    ld.global.f32  %f2, [%rd6 + 4];
    atom.global.add.f32 %f3, [%rd7], %f1;
    red.global.add.f32 [%rd7 + 8], %f2;
    st.global.f32  [%rd7], %f3;

Exit:
    ret;
}
)";

static const std::string EMPTY_PTX = R"(.version 8.8
.target sm_60
.address_size 64

.visible .entry emptyKernel()
{
    ret;
}
)";

static const std::string NO_GLOBAL_ACCESS_PTX = R"(.version 8.8
.target sm_60
.address_size 64

.visible .entry localOnlyKernel(
    .param .u32 value
)
{
    .reg .b32  %r<5>;
    .reg .f32  %f<3>;

    ld.param.u32   %r1, [value];
    mov.u32    %r2, %tid.x;
    add.u32    %r3, %r1, %r2;
    cvt.rn.f32.u32 %f1, %r3;
    mul.f32    %f2, %f1, 0f40000000;

    ret;
}
)";

void SfNvccPatternMatchingTest::SetUp()
{
	temp_file = fs::temp_directory_path() / "temp_test.ptx";
}

void SfNvccPatternMatchingTest::TearDown()
{
	if (fs::exists(temp_file)) {
		fs::remove(temp_file);
	}
}

void SfNvccPatternMatchingTest::write_ptx(const std::string_view content) const
{
	std::ofstream ofs(temp_file);
	ofs << content;
	ofs.close();
}

/**
 * @brief Tests detection of global memory load instructions
 *
 * Verifies that ld.global.* instructions are correctly identified
 * and returned with proper line numbers and lexeme parsing.
 */
TEST_F(SfNvccPatternMatchingTest, GlobalLoadInstructionDetection)
{
	write_ptx(SCALE_ARRAY_PTX);

	auto instructions = sf_nvcc::find_all_ptx(temp_file.string());

	// Should find exactly 2 global memory instructions (1 load, 1 store)
	ASSERT_EQ(instructions.size(), 2);

	// First instruction should be ld.global.f32
	const auto &load_instr = instructions[0];
	EXPECT_EQ(load_instr.lexemes[0], "ld.global.f32");
	EXPECT_EQ(load_instr.lexemes[1], "%f1");
	EXPECT_EQ(load_instr.lexemes[2], "[");
	EXPECT_EQ(load_instr.lexemes[3], "%rd4");
	EXPECT_EQ(load_instr.lexemes[4], "]");
	EXPECT_GT(load_instr.line_number, 0);
}

/**
 * @brief Tests detection of global memory store instructions
 *
 * Validates that st.global.* instructions are properly identified
 * with correct lexeme tokenization and line number tracking.
 */
TEST_F(SfNvccPatternMatchingTest, GlobalStoreInstructionDetection)
{
	write_ptx(ADD_ONE_PTX);

	auto instructions = sf_nvcc::find_all_ptx(temp_file.string());

	// Should find exactly 2 global memory instructions (1 load, 1 store)
	ASSERT_EQ(instructions.size(), 2);

	// Second instruction should be st.global.f32
	const auto &store_instr = instructions[1];
	EXPECT_EQ(store_instr.lexemes[0], "st.global.f32");
	EXPECT_EQ(store_instr.lexemes[1], "[");
	EXPECT_EQ(store_instr.lexemes[2], "%rd4");
	EXPECT_EQ(store_instr.lexemes[3], "]");
	EXPECT_EQ(store_instr.lexemes[4], "%f2");
	EXPECT_GT(store_instr.line_number, 0);
}

/**
 * @brief Tests detection of atomic global memory operations
 *
 * Verifies that atom.global.* instructions are correctly identified
 * and included in the pattern matching results.
 */
TEST_F(SfNvccPatternMatchingTest, GlobalAtomicInstructionDetection)
{
	write_ptx(COMPLEX_GLOBAL_PTX);

	auto instructions = sf_nvcc::find_all_ptx(temp_file.string());

	// Should find 5 global memory instructions: 2 loads, 1 atomic, 1 reduction, 1 store
	ASSERT_EQ(instructions.size(), 5);

	// Find the atomic instruction
	bool found_atomic = false;
	for (const auto &instr : instructions) {
		if (instr.lexemes[0] == "atom.global.add.f32") {
			found_atomic = true;
			EXPECT_EQ(instr.lexemes[1], "%f3");
			EXPECT_EQ(instr.lexemes[2], "[");
			EXPECT_EQ(instr.lexemes[3], "%rd7");
			EXPECT_EQ(instr.lexemes[4], "]");
			EXPECT_EQ(instr.lexemes[5], "%f1");
			break;
		}
	}
	EXPECT_TRUE(found_atomic);
}

/**
 * @brief Tests detection of global memory reduction operations
 *
 * Validates that red.global.* instructions are properly identified
 * and processed by the pattern matcher.
 */
TEST_F(SfNvccPatternMatchingTest, GlobalReductionInstructionDetection)
{
	write_ptx(COMPLEX_GLOBAL_PTX);

	auto instructions = sf_nvcc::find_all_ptx(temp_file.string());

	bool found_reduction = false;
	for (const auto &instr : instructions) {
		if (instr.lexemes[0] == "red.global.add.f32") {
			found_reduction = true;
			EXPECT_EQ(instr.lexemes[1], "[");
			EXPECT_EQ(instr.lexemes[2], "%rd7");
			EXPECT_EQ(instr.lexemes[3], "+");
			EXPECT_EQ(instr.lexemes[4], "8");
			EXPECT_EQ(instr.lexemes[5], "]");
			EXPECT_EQ(instr.lexemes[6], "%f2");
			break;
		}
	}
	EXPECT_TRUE(found_reduction);
}

/**
 * @brief Tests handling of PTX files with no global memory instructions
 *
 * Verifies that kernels without global memory access return empty
 * instruction vectors without errors.
 */
TEST_F(SfNvccPatternMatchingTest, NoGlobalInstructionsHandling)
{
	write_ptx(NO_GLOBAL_ACCESS_PTX);

	auto instructions = sf_nvcc::find_all_ptx(temp_file.string());

	EXPECT_EQ(instructions.size(), 0);
}

/**
 * @brief Tests handling of empty PTX files
 *
 * Validates that minimal PTX files with no instructions
 * are processed correctly without throwing exceptions.
 */
TEST_F(SfNvccPatternMatchingTest, EmptyPtxFileHandling)
{
	write_ptx(EMPTY_PTX);

	auto instructions = sf_nvcc::find_all_ptx(temp_file.string());

	EXPECT_EQ(instructions.size(), 0);
}

/**
 * @brief Tests proper line number tracking across multiple instructions
 *
 * Verifies that line numbers are correctly assigned and maintained
 * for multiple global memory access instructions in the same file.
 */
TEST_F(SfNvccPatternMatchingTest, LineNumberAccuracy)
{
	write_ptx(SCALE_ARRAY_PTX);

	auto instructions = sf_nvcc::find_all_ptx(temp_file.string());

	ASSERT_GE(instructions.size(), 2);

	// Line numbers should be in ascending order
	for (size_t i = 1; i < instructions.size(); ++i) {
		EXPECT_GT(instructions[i].line_number,
			  instructions[i - 1].line_number);
	}

	// Line numbers should be reasonable (not negative, not too large)
	for (const auto &instr : instructions) {
		EXPECT_GT(instr.line_number, 0);
		EXPECT_LT(instr.line_number, 100);
	}
}

/**
 * @brief Tests lexeme tokenization accuracy for various instruction formats
 *
 * Validates that different PTX instruction formats are correctly
 * parsed into individual lexemes with proper bracket and comma handling.
 */
TEST_F(SfNvccPatternMatchingTest, LexemeTokenizationAccuracy)
{
	write_ptx(COMPLEX_GLOBAL_PTX);

	auto instructions = sf_nvcc::find_all_ptx(temp_file.string());

	bool found_complex_load = false;
	for (const auto &instr : instructions) {
		if (instr.lexemes.size() >= 6 &&
		    instr.lexemes[0].find("ld.global") == 0 &&
		    instr.lexemes[3] == "%rd6" && instr.lexemes[4] == "+") {
			found_complex_load = true;

			// Verify proper tokenization of [%rd6 + 4]
			EXPECT_EQ(instr.lexemes[2], "[");
			EXPECT_EQ(instr.lexemes[3], "%rd6");
			EXPECT_EQ(instr.lexemes[4], "+");
			EXPECT_EQ(instr.lexemes[5], "4");
			EXPECT_EQ(instr.lexemes[6], "]");
			break;
		}
	}
	EXPECT_TRUE(found_complex_load);
}

/**
 * @brief Tests filtering of non-instruction lines
 *
 * Verifies that comments, directives, labels, and other non-instruction
 * lines are properly skipped during pattern matching.
 */
TEST_F(SfNvccPatternMatchingTest, NonInstructionLineFiltering)
{
	const std::string ptx_with_noise = R"(.version 8.8
.target sm_60
.address_size 64
// This is a comment
    // Another comment
.visible .entry testKernel(
    .param .u64 data_ptr
)
{
    .reg .b64  %rd<3>;

    // Load parameter
    ld.param.u64   %rd1, [data_ptr];
    cvta.to.global.u64     %rd2, %rd1;

    // Global memory access
    ld.global.f32  %f1, [%rd2];

$L_EXIT:
    ret;

}
)";

	write_ptx(ptx_with_noise);

	auto instructions = sf_nvcc::find_all_ptx(temp_file.string());

	// Should only find the one global memory instruction, not comments or labels
	ASSERT_EQ(instructions.size(), 1);
	EXPECT_EQ(instructions[0].lexemes[0], "ld.global.f32");
}

/**
 * @brief Tests error handling for non-existent files
 *
 * Validates that attempting to parse a non-existent PTX file
 * throws appropriate runtime_error exception.
 */
TEST_F(SfNvccPatternMatchingTest, NonExistentFileHandling)
{
	const std::string non_existent_file = "/tmp/does_not_exist.ptx";

	EXPECT_THROW(sf_nvcc::find_all_ptx(non_existent_file),
		     std::runtime_error);
}

/**
 * @brief Tests register extraction from memory access patterns
 *
 * Verifies that address registers are correctly identified from
 * various global memory access patterns with different syntaxes.
 */
TEST_F(SfNvccPatternMatchingTest, AddressRegisterExtraction)
{
	write_ptx(SCALE_ARRAY_PTX);

	auto instructions = sf_nvcc::find_all_ptx(temp_file.string());

	ASSERT_GE(instructions.size(), 1);

	// Both instructions should use %rd4 as the address register
	for (const auto &instr : instructions) {
		bool found_address_reg = false;
		for (size_t i = 0; i < instr.lexemes.size() - 1; ++i) {
			if (instr.lexemes[i] == "[" &&
			    instr.lexemes[i + 1] == "%rd4") {
				found_address_reg = true;
				break;
			}
		}
		EXPECT_TRUE(found_address_reg)
			<< "Address register %rd4 not found in instruction";
	}
}

/**
 * @brief Tests processing of multiple different global instruction types
 *
 * Validates that a mix of load, store, atomic, and reduction instructions
 * are all correctly identified and processed in a single PTX file.
 */
TEST_F(SfNvccPatternMatchingTest, MultipleInstructionTypesProcessing)
{
	write_ptx(COMPLEX_GLOBAL_PTX);

	auto instructions = sf_nvcc::find_all_ptx(temp_file.string());

	EXPECT_GE(instructions.size(), 4);

	int load_count = 0, store_count = 0, atomic_count = 0,
	    reduction_count = 0;

	for (const auto &instr : instructions) {
		const std::string &op = instr.lexemes[0];
		if (op.find("ld.global") == 0)
			load_count++;
		else if (op.find("st.global") == 0)
			store_count++;
		else if (op.find("atom.global") == 0)
			atomic_count++;
		else if (op.find("red.global") == 0)
			reduction_count++;
	}

	EXPECT_GE(load_count, 1);
	EXPECT_GE(store_count, 1);
	EXPECT_GE(atomic_count, 1);
	EXPECT_GE(reduction_count, 1);
}
