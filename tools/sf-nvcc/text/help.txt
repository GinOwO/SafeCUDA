sf-nvcc - SafeCUDA NVCC wrapper for GPU memory safety

DESCRIPTION
    sf-nvcc is a drop-in replacement for nvcc that automatically injects
    bounds checking into CUDA kernels. It intercepts compilation, modifies
    PTX assembly to add memory safety checks, and produces binaries with
    spatial memory violation detection.

USAGE
    sf-nvcc [-sf-version] [-sf-help] [-sf-bounds-check <true|false>]
            [-sf-debug <true|false>] [-sf-verbose <true|false>]
            [-sf-cache-size <value>] [-sf-fail-fast <true|false>]
            [-sf-logging <path>] <nvcc args>

SAFECUDA OPTIONS
    -sf-help
        Show this help message and exit

    -sf-version
        Display sf-nvcc version and applicable SafeCUDA build info.

    -sf-bounds-check <true|false>
        Enable or disable spatial memory bounds checking injection (default: true)
        When enabled, PTX is modified to validate all global memory accesses

    -sf-debug <true|false>
        Enable debug mode with detailed PTX modification logging (default: false)
        Shows which instructions are being instrumented and metadata operations

    -sf-verbose <true|false>
        Enable verbose compilation output (default: false)
        Displays arguments, PTX generation, modification steps, and compilation progress

    -sf-cache-size <value>
        Set shared memory cache size for metadata in bytes (default: 256)
        Larger caches improve performance but use more shared memory per block

    -sf-fail-fast <true|false>
        Abort kernel execution on first bounds violation (default: false)
        When false, violations are logged but execution continues

    -sf-log-violations <true|false>
        Set if violations should be logged or not (default: false)
        Logs are outputted to path specified by -sf-log-path

    -sf-log-path <path>
        Log bounds violations to specified file (default: stderr)
        Only logs if -sf-log-violations is set to true

NVCC COMPATIBILITY
    All standard nvcc options are passed through unchanged. sf-nvcc acts as a
    transparent wrapper, so existing build systems work without modification.

    Examples:
        sf-nvcc -arch=sm_75 kernel.cu -o program
        sf-nvcc -sf-debug true -sf-cache-size 512 -O3 kernel.cu -o program

RUNTIME REQUIREMENTS
    Compiled binaries require LD_PRELOAD with libsafecuda.so:
        LD_PRELOAD=libsafecuda.so ./program

    The SafeCUDA library handles allocation tracking and violation reporting.

SEE ALSO
    nvcc(1), cuda-gdb(1)
