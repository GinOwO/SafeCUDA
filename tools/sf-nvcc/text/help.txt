sf-nvcc - SafeCUDA NVCC wrapper for GPU memory safety

DESCRIPTION
    sf-nvcc is a drop-in replacement for nvcc that automatically injects
    bounds checking into CUDA kernels with the help of sf-nvcc. It intercepts
    compilation, modifies PTX assembly to add memory safety checks, and produces
    binaries with spatial memory violation detection.

USAGE
    sf-nvcc [-sf-version] [-sf-help] [-sf-bounds-check <TRUE|false>]
            [-sf-debug <true|FALSE>] [-sf-verbose <true|FALSE>]
            [-sf-fail-fast <true|FALSE>] [-sf-log-violations <true|FALSE>]
            [-sf-log-path <path>] [-sf-keep-dir <path>] <nvcc args>

SAFECUDA OPTIONS
    -sf-help
        Show this help message and exit

    -sf-version
        Display sf-nvcc version and applicable SafeCUDA build info.

    -sf-bounds-check <TRUE|false>
        Enable or disable spatial memory bounds checking injection (default: true)
        When enabled, PTX is modified to validate all global memory accesses

    -sf-debug <true|FALSE>
        Enable debug mode with detailed PTX modification logging (default: false)
        Shows which instructions are being instrumented and metadata operations
        If enabled also enables verbose.

    -sf-verbose <true|FALSE>
        Enable verbose compilation output (default: false)
        Displays arguments, PTX generation, modification steps, and compilation progress

    -sf-fail-fast <TRUE|false>
        Abort kernel execution on first bounds violation (default: true)
        When false, first violation is logged but kernel execution continues

    -sf-log-violations <true|FALSE>
        Set if violations should be logged or not (default: false)
        Logs are outputted to path specified by -sf-log-path

    -sf-log-path <path>
        Log bounds violations to specified file (default: stderr)
        Only logs if -sf-log-violations is set to true

    -sf-keep-dir <path>
        Path to store intermediate files (default: system temp dir)

NVCC COMPATIBILITY
    All standard nvcc options are passed through unchanged. sf-nvcc acts as a
    transparent wrapper, so existing build systems work without modification.

    Examples:
        sf-nvcc -arch=sm_75 kernel.cu -o program
        sf-nvcc -sf-debug true -sf-cache-size 512 -O3 kernel.cu -o program

RUNTIME REQUIREMENTS
    Compiled binaries require LD_PRELOAD with libsafecuda.so:
        LD_PRELOAD=libsafecuda.so ./program

    The SafeCUDA library handles allocation tracking and violation reporting.

SEE ALSO
    nvcc(1), cuda-gdb(1)
