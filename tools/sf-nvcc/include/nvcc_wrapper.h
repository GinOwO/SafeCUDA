/**
 * @file nvcc_wrapper.h
 * @brief NVCC compiler wrapper for SafeCUDA PTX modification pipeline
 *
 * Provides functionality to intercept NVCC compilation, generate PTX,
 * coordinate PTX modification, and resume compilation from modified PTX.
 *
 * @author Kiran <kiran.pdas2022@vitstudent.ac.in>
 * @date 2025-08-12
 * @version 1.1.0
 * @copyright Copyright (c) 2025 SafeCUDA Project. Licensed under GPL v3.
 *
 * Change Log:
 * - 2025-10-28: Refactored to use nvcc -dryrun command orchestration
 * - 2025-09-23: Implemented resume_nvcc and rewrote stuff around NvccOptions
 * - 2025-09-22: Moved modify ptx to ptx_modifier and implemented resume_nvcc
 * - 2025-08-13: Created NVCC wrapper methods,
 *		 added PtxModificationResult and TemporaryFileManager
 * - 2025-08-12: Initial File
 */

#ifndef SAFECUDA_NVCC_WRAPPER_H
#define SAFECUDA_NVCC_WRAPPER_H

#include "sf_options.h"
#include "ptx_modifier.h"
#include <filesystem>
#include <string>
#include <unordered_map>
#include <vector>

namespace safecuda::tools::sf_nvcc
{

/**
 * @brief RAII wrapper for managing temporary compilation files
 *
 * Tracks intermediate files and ensures cleanup on failure. Provides
 * thread-safe access to temporary file paths and optional file preservation
 * for debugging.
 *
 * @note This class is move-only to ensure unique ownership of temp directories
 * @note Not thread-safe - each compilation thread should have its own instance
 */
class TemporaryFileManager {
	bool preserve_on_exit;
	std::filesystem::path dir_path;
	std::vector<std::filesystem::path> temp_files;

    public:
	explicit TemporaryFileManager(const SafeCudaOptions &sf_opts);
	~TemporaryFileManager();
	TemporaryFileManager(const TemporaryFileManager &) = delete;
	TemporaryFileManager &operator=(const TemporaryFileManager &) = delete;
	TemporaryFileManager(TemporaryFileManager &&) = default;
	TemporaryFileManager &operator=(TemporaryFileManager &&) = default;

	/**
     * @brief Returns the working directory being used, else use temp directory
     *
     * @return Working folder directory
     */
	[[nodiscard]] std::filesystem::path get_working_dir() const noexcept;

	/**
     * @brief Filter PTX files from intermediate files
     *
     * Filters PTX files (.ptx extension) from NVCC intermediate files.
     *
     * @return Vector of valid PTX file paths
     */
	[[nodiscard]] std::vector<std::filesystem::path>
	filter_ptx_paths() const noexcept;

	/**
     * @brief Returns list of all intermediate files generated by nvcc
     *
     * @return Vector of all intermediate files generated
     */
	[[nodiscard]] std::vector<std::filesystem::path>
	get_intermediate_files() const noexcept;

	/**
     * @brief Add a file path to store;
     */
	void add_file(const std::filesystem::path &path) noexcept;
};

/**
 * @brief Parser for nvcc -dryrun output
 *
 * Parses the command sequence produced by nvcc -dryrun and identifies
 * compilation stages, particularly PTX generation commands.
 */
struct DryRunParser {
	std::vector<std::string> commands; ///< All commands from dryrun
	std::unordered_map<std::string, std::string>
		ptx_files; ///< Maps PTX paths to source files
	size_t ptx_stage_end_index{0}; ///< Index after last PTX generation

	/**
     * @brief Parse nvcc -dryrun output into command stages
     *
     * @param dryrun_output The full output from nvcc -dryrun
     * @throws std::runtime_error if parsing fails
     */
	void parse(const std::string &dryrun_output);

	/**
     * @brief Get commands that execute up to and including PTX generation
     *
     * @return Vector of commands to execute before PTX modification
     */
	[[nodiscard]] std::vector<std::string> get_pre_ptx_commands() const;

	/**
     * @brief Get commands that execute after PTX generation
     *
     * @param modified_ptx_map Map from original PTX paths to modified PTX paths
     * @return Vector of commands with modified PTX paths substituted
     */
	[[nodiscard]] std::vector<std::string>
	get_post_ptx_commands(const std::unordered_map<std::string, std::string>
				      &modified_ptx_map) const;
};

/**
 * @brief Execute nvcc -dryrun and parse the compilation pipeline
 *
 * Runs nvcc with -dryrun flag using user's original arguments to extract
 * the exact sequence of compilation commands nvcc would execute.
 *
 * @param nvcc_opts NVCC arguments including source files and compilation flags
 * @param sf_opts SafeCUDA options for controlling compilation
 * @return DryRunParser containing parsed command sequence
 * @throws std::runtime_error if nvcc -dryrun execution fails
 */
DryRunParser execute_dryrun(const NvccOptions &nvcc_opts,
			    const SafeCudaOptions &sf_opts);

/**
 * @brief Execute pre-PTX compilation commands
 *
 * Executes all commands from preprocessing through PTX generation,
 * collecting intermediate PTX file paths for modification.
 *
 * @param parser DryRunParser with pre-PTX commands
 * @param sf_opts SafeCUDA options for controlling execution
 * @param temp_mgr TemporaryFileManager to track generated files
 * @return Vector of generated PTX file paths
 * @throws std::runtime_error if any command execution fails
 */
std::vector<std::filesystem::path>
execute_pre_ptx_stage(const DryRunParser &parser,
		      const SafeCudaOptions &sf_opts,
		      TemporaryFileManager &temp_mgr);

/**
 * @brief Execute post-PTX compilation commands with modified PTX
 *
 * Executes remaining commands (ptxas, fatbinary, linking) using
 * SafeCUDA-modified PTX files instead of original PTX.
 *
 * @param modified_ptx_map Map from original PTX paths to modified PTX paths
 * @param parser DryRunParser with post-PTX commands
 * @param sf_opts SafeCUDA options for controlling execution
 * @return true if compilation completes successfully
 * @throws std::runtime_error if any command execution fails
 */
bool execute_post_ptx_stage(
	const std::unordered_map<std::string, std::string> &modified_ptx_map,
	const DryRunParser &parser, const SafeCudaOptions &sf_opts,
	const NvccOptions &nvcc_opts);

} // namespace safecuda::tools::sf_nvcc

#endif // SAFECUDA_NVCC_WRAPPER_H
