/**
 * @file nvcc_wrapper.h
 * @brief NVCC compiler wrapper for SafeCUDA PTX modification pipeline
 *
 * Provides functionality to intercept NVCC compilation, generate PTX,
 * coordinate PTX modification, and resume compilation from modified PTX.
 *
 * @author Kiran <kiran.pdas2022@vitstudent.ac.in>
 * @date 2025-08-12
 * @version 0.0.1
 * @copyright Copyright (c) 2025 SafeCUDA Project. Licensed under GPL v3.
 *
 * Change Log:
 * - 2025-08-12: Initial File
 * - 2025-08-13: Created NVCC wrapper methods,
 *		added PtxModificationResult and TemporaryFileManager
 */

#ifndef SAFECUDA_NVCC_WRAPPER_H
#define SAFECUDA_NVCC_WRAPPER_H

#include <vector>
#include <string>
#include <filesystem>

#include "sf_options.h"

namespace safecuda::tools::sf_nvcc
{
/**
 * @brief RAII wrapper for managing temporary compilation files
 *
 * Tracks intermediate files and ensures cleanup on failure. Provides
 * thread-safe access to temporary file paths and optional file preservation
 * for debugging.
 *
 * @note This class is move-only to ensure unique ownership of temp directories
 * @note Not thread-safe - each compilation thread should have its own instance
 */
class TemporaryFileManager {
	bool preserve_on_exit;
	std::filesystem::path dir_path;
	std::vector<std::filesystem::path> temp_files;

    public:
	explicit TemporaryFileManager(const SafeCudaOptions &sf_opts);
	~TemporaryFileManager();

	TemporaryFileManager(const TemporaryFileManager &) = delete;
	TemporaryFileManager &operator=(const TemporaryFileManager &) = delete;
	TemporaryFileManager(TemporaryFileManager &&) = default;
	TemporaryFileManager &operator=(TemporaryFileManager &&) = default;

	/**
	 * @brief Returns the working directory being used, else use temp directory
	 *
	 * @return Working folder directory
	 */
	[[nodiscard]] std::filesystem::path get_working_dir() const noexcept;

	/**
	 * @brief Filter PTX files from intermediate files
	 *
	 * Filters PTX files (.ptx extension) from NVCC intermediate files.
	 *
	 * @return Vector of valid PTX file paths
	 */
	[[nodiscard]] std::vector<std::filesystem::path>
	filter_ptx_paths() const noexcept;

	/**
	 * @brief Returns list of all intermediate files generated by nvcc
	 *
	 * @return Vector of all intermediate files generated
	 */
	[[nodiscard]] std::vector<std::filesystem::path>
	get_intermediate_files() const noexcept;

	/**
	 * @brief Add a file path to store;
	 */
	void add_file(const std::filesystem::path &path) noexcept;
};

/**
 * @brief Result of PTX modification operation with detailed statistics
 *
 * Contains success status, modification counts, and diagnostic messages
 * for logging and error reporting purposes.
 */
struct PtxModificationResult {
	bool success;
	size_t instructions_modified;
	size_t bounds_checks_added;
	std::vector<std::string> warnings;
	std::vector<std::string> errors;
	std::string modified_ptx_path;
	double modification_time_ms = 0.0;
};

/**
 * @brief Generate PTX intermediate files using NVCC --keep
 *
 * Executes NVCC with --keep flag to preserve all intermediate compilation
 * files including PTX assembly. Handles multiple source files and different
 * GPU architectures specified in nvcc_args.
 *
 * @param nvcc_args NVCC arguments including source files and compilation flags
 * @param sf_opts SafeCUDA options for controlling PTX generation
 * @param temp_mgr TemporaryFileManager to manage intermediate file paths
 * @throws std::runtime_error if NVCC execution fails
 *
 * @note Temporary files are created according to -sf-keep-dir (and if not given
 * then system temp directory)
 */
void generate_intermediate(const std::vector<std::string> &nvcc_args,
			   const SafeCudaOptions &sf_opts,
			   TemporaryFileManager &temp_mgr);

/**
 * @brief Insert guards to a generated PTX file
 *
 * Perform parsing PTX assembly, identifying memory operations,
 * and injecting bounds checking macros into load/store instructions.
 *
 * @param ptx_path Path of ptx file to be modified
 * @param sf_opts SafeCUDA options for controlling PTX modification
 * @return PtxModificationResult done by the function for logging purposes
 *
 * @throws std::runtime_error if PTX parsing fails or modification generates invalid code
 * @throws std::filesystem::filesystem_error if modified files cannot be written
 * @note Original files are preserved with "og_" prefix for debugging if sf_opts.enable_debug is true
 */
PtxModificationResult modify_ptx(const std::filesystem::path &ptx_path,
				 const SafeCudaOptions &sf_opts);

/**
 * @brief Resume compilation with nvcc on intermediate files
 *
 * Invokes NVCC to continue compilation from the modified PTX files and other
 * intermediate files, producing the final executable or object files with
 * SafeCUDA bounds checking integrated.
 *
 * @param intermediate_paths List of paths of all intermediate nvcc files
 * @param nvcc_args NVCC arguments including source files and compilation flags
 * @return true if nvcc completed successfully, false otherwise
 * @throws std::runtime_error if nvcc fails to compile
 */
bool resume_nvcc(const std::vector<std::string> &intermediate_paths,
		 const std::vector<std::string> &nvcc_args);

} // namespace safecuda::tools::sf_nvcc

#endif // SAFECUDA_NVCC_WRAPPER_H
