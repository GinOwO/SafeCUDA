/**
 * @file nvcc_wrapper.h
 * @brief NVCC compiler wrapper for SafeCUDA PTX modification pipeline
 *
 * Provides functionality to intercept NVCC compilation, generate PTX,
 * coordinate PTX modification, and resume compilation from modified PTX.
 *
 * @author Kiran <kiran.pdas2022@vitstudent.ac.in>
 * @date 2025-08-12
 * @version 1.0.0
 * @copyright Copyright (c) 2025 SafeCUDA Project. Licensed under GPL v3.
 *
 * Change Log:
 * - 2025-09-23: Implemented resume_nvcc and rewrote stuff around NvccOptions
 * - 2025-09-22: Moved modify ptx to ptx_modifier and implemented resume_nvcc
 * - 2025-08-13: Created NVCC wrapper methods,
 *		 added PtxModificationResult and TemporaryFileManager
 * - 2025-08-12: Initial File
 */

#ifndef SAFECUDA_NVCC_WRAPPER_H
#define SAFECUDA_NVCC_WRAPPER_H

#include "sf_options.h"
#include "ptx_modifier.h"

#include <vector>
#include <string>
#include <filesystem>
#include <unordered_map>

namespace safecuda::tools::sf_nvcc
{
/**
 * @brief RAII wrapper for managing temporary compilation files
 *
 * Tracks intermediate files and ensures cleanup on failure. Provides
 * thread-safe access to temporary file paths and optional file preservation
 * for debugging.
 *
 * @note This class is move-only to ensure unique ownership of temp directories
 * @note Not thread-safe - each compilation thread should have its own instance
 */
class TemporaryFileManager {
	bool preserve_on_exit;
	std::filesystem::path dir_path;
	std::vector<std::filesystem::path> temp_files;

    public:
	explicit TemporaryFileManager(const SafeCudaOptions &sf_opts);
	~TemporaryFileManager();

	TemporaryFileManager(const TemporaryFileManager &) = delete;
	TemporaryFileManager &operator=(const TemporaryFileManager &) = delete;
	TemporaryFileManager(TemporaryFileManager &&) = default;
	TemporaryFileManager &operator=(TemporaryFileManager &&) = default;

	/**
	 * @brief Returns the working directory being used, else use temp directory
	 *
	 * @return Working folder directory
	 */
	[[nodiscard]] std::filesystem::path get_working_dir() const noexcept;

	/**
	 * @brief Filter PTX files from intermediate files
	 *
	 * Filters PTX files (.ptx extension) from NVCC intermediate files.
	 *
	 * @return Vector of valid PTX file paths
	 */
	[[nodiscard]] std::vector<std::filesystem::path>
	filter_ptx_paths() const noexcept;

	/**
	 * @brief Returns list of all intermediate files generated by nvcc
	 *
	 * @return Vector of all intermediate files generated
	 */
	[[nodiscard]] std::vector<std::filesystem::path>
	get_intermediate_files() const noexcept;

	/**
	 * @brief Add a file path to store;
	 */
	void add_file(const std::filesystem::path &path) noexcept;
};

/**
 * @brief Generate PTX intermediate files using NVCC --keep
 *
 * Executes NVCC with --keep flag to preserve all intermediate compilation
 * files including PTX assembly. Handles multiple source files and different
 * GPU architectures specified in nvcc_args.
 *
 * @param nvcc_args NVCC arguments including source files and compilation flags
 * @param sf_opts SafeCUDA options for controlling PTX generation
 * @param temp_mgr TemporaryFileManager to manage intermediate file paths
 * @throws std::runtime_error if NVCC execution fails
 *
 * @note Temporary files are created according to -sf-keep-dir (and if not given
 * then system temp directory)
 */
void generate_intermediate(const NvccOptions &nvcc_opts,
			   const SafeCudaOptions &sf_opts,
			   TemporaryFileManager &temp_mgr);

/**
 * @brief Resume compilation with nvcc on intermediate files
 *
 * Invokes NVCC to continue compilation from the modified PTX files and other
 * intermediate files, producing the final executable or object files with
 * SafeCUDA bounds checking integrated.
 *
 * @param ptx_paths List of paths of all ptx files to resume from
 * @param sf_nvcc_opts NVCC arguments including source files and compilation flags
 * @return true if nvcc completed successfully, false otherwise
 * @throws std::runtime_error if nvcc fails to compile
 * @throws std::filesystem::filesystem_error if unable find files in paths
 *
 * @note nvlink warnings like `SM Arch ('sm_52') not found in` are expected and
 *	a normal part of multi-arch compilation in nvcc with ptx
 */
bool resume_nvcc(const std::vector<std::filesystem::path> &ptx_paths,
		 const SfNvccOptions &sf_nvcc_opts,
		 TemporaryFileManager &temp_mgr);

} // namespace safecuda::tools::sf_nvcc

#endif // SAFECUDA_NVCC_WRAPPER_H
